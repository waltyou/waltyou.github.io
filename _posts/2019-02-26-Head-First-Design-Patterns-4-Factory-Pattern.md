---
layout: post
title: 《HeadFirst设计模式》学习日志（四）:工厂模式
date: 2019-02-26 14:18:00
author: admin
comments: true
categories: [Java]
tags: [Java,Design Patterns]
---



<!-- more -->

------

学习资料主要参考： 《Head First 设计模式》

------

## 目录
{:.no_toc}

* 目录
{:toc}
------

创建一个新对象时，过度地使用new操作符，会带来“耦合”问题，这时候就要考虑来使用**工厂模式**。

## 简单工厂：封装创建对象的代码

回忆两个原则：1. 隔离变化部分和不变化部分； 2. 对修改封闭，对拓展开放。

所以应该把使用new创建对象的代码，统一封装成另外一个类，这个类就叫做“**工厂**”。

工厂负责创建对象的细节。

## 工厂方法模式

### 工厂方法

工厂方法用来处理对象的创建，并将这样的行为封装在子类（通过抽象类的方式），这样子决定权就交给了子类，达到了解耦的目的。

```
abstract Product factoryMethod(String type);
```

### 两部分

1. 创建者：抽象创建者、具体创建者。
2. 产品类：工厂所生产的产品。

### 正式定义

> 定义了一个创建对象的接口，但由子类决定来实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

[![](/images/posts/factory-pattern.png)](/images/posts/factory-pattern.png)

### 优点

将创建对象的代码集中在一个对象或者方法中，可以避免代码中的重复，而且方便以后的运维。

## 依赖倒置原则

> 要依赖抽象，不要依赖具体类。

### “倒置”是什么意思？

以前是高层组件依赖低层组件，但是如果遵循依赖倒置原则后，底层组件也开始依赖高层组件了。

“先考虑有哪些具体的类，然后考虑是否可以为它们建立一个抽象”，这个思路就是倒置的思路。

### 指导方针

- 变量不可以持有具体类的引用：改用工厂方法
- 不要让类派生自具体类：抽象出一个基类
- 不要覆盖基类中已存在的方法：基类中的已实现方法应该由所有子类共用

## 抽象工厂模式

> 提供一个接口，用于创建相关和依赖对象的家族，而不需要明确指定具体类。

抽象工厂的方法经常以工厂方法的方式实现。

抽象工厂的任务是定义一个负责创建一组产品的接口。

## 抽象工厂与工厂方法的异同

### 相同点

- 都负责创建对象
- 都通过减少应用程序和具体类之间的依赖来解耦

### 不同点

- 创建对象：工厂方法用的是继承，把对象的创建委托给子类，子类通过工厂方法创建对象；抽象工厂使用对象的组合，对象的创建被实现在工厂接口所暴露出来的方法中。
- 工厂方法：具体功能由子类完成；抽象工厂：创建产品家族，可以将制造的产品集合起来。
- 抽象工厂：创建相关的对象家族，而不需要依赖它们的具体类。

