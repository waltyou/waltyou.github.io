---
layout: post
title: Java 并发编程实战-学习日志（四）2：自定义同步器
date: 2020-03-10 18:11:04
author: admin
comments: true
categories: [Java]
tags: [Java, Concurrency, Java Concurrency In Practice]
---

"与基于锁的方案相比，非阻塞算法在设计和实现上都要复杂的多，但他们在可伸缩性和活跃性上却拥有巨大的优势。
由于非阻塞算法可以使用多个线程在竞争相同的数据时不会发生阻塞，因此它能在粒度更细的层次上进行协调。"

<!-- more -->

---

* 目录
{:toc}
---

## 锁的劣势

现代的许多JVM都对**非竞争锁获取**和**锁释放**等操作进行了极大的优化，但如果有多个线程同时请求锁，那么JVM就需要借助操作系统的功能。如果出现了这种情况，那么一些线程将被挂起并且在稍后恢复运行。

当线程恢复执行时，必须等待其他线程执行完他们的时间以后，才能被调度执行。**在挂起和恢复线程等过程中存在很大的开销，并且通常存在这个较长时间的中断**。如果在基于锁的类包中包含有细粒度的操作，(例如同步容器类，在其大多数方法中只包含少量的并发操作),那么当在锁上存在激烈的竞争时，调度开销和工作开销的比值会非常高。

与锁相比，volatile变量是一种更轻量级的同步机制，因为在使用这些变量时不会发生上下文切换和线程调度等操作。然而，volatile变量同样存在一些局限:虽然和锁机制相似的都提供了可见性保证，但是不能用于构建原子的复合操作。因此，当一个变量依赖其他变量时，或者当变量的新值依赖旧值是，就不能使用volatile变量。这些都限制了volatile变量的使用，因此volatile不能用来实现一些常用的操作，比如计数器或者互斥量。

锁定还存在其他的一些缺点。但一个线程正在等待锁时，他不能做任何其他事情。如果一个线程在持有锁的情况下被延迟执行(例如发生了缺页错误，调度延迟，或者其他类似情况)，那么所有需要这个锁的线程都无法执行下去。如果被阻塞线程的优先级很高，而持有锁的线程有限级较低，那么这个将是一个很严重的问题——也被称为优先级反转(Priority Inversion)。即使高有限级的线程可以抢先执行，但是仍然需要等待锁被释放，从而导致它的有限级会降至低优先级线程的级别。如果持有锁的线程被永久的阻塞(例如出现了无线循环，死锁，活锁或者其他活跃性故障)，所有等待这个锁的线程就会永远无法执行下去。

即使忽略这些风险，锁定方式对于细粒度的操作(例如递增计数器)来说任然是一种高开消的机制。在管理线程之间的竞争是应该有一种粒度更细的技术，类似于volatile变量的机制，同时还要支持原子的更新操作。





## 未完待续。。。。