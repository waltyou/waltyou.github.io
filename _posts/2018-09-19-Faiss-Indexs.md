---
layout: post
title: Faiss 进阶
date: 2018-09-19 09:29:04
author: admin
comments: true
categories: [Faiss]
tags: [Image Search]
---

在上一篇，我们知道了 Index 是 Faiss 最重要的一部分，来详细了解它们。

<!-- more -->

---
## 目录
{:.no_toc}

* 目录
{:toc}
---

# 挑一个合适的 Index

Faiss 提供了很多 Index，那么如何根据实际情况选择 Index 呢？

可以以下根据几个必要的问题，来找到自己合适的 Index 类型。

需要注意：
- 以下都通过 index_factory 字符串来表示不同 Index
- 如果需要参数，使用相应的 ParameterSpace 参数

## 1. 是否需要精确的结果？

### 那就使用 “Flat”

可以保证精确结果的唯一索引是 IndexFlatL2。

它为其他索引的结果提供基线。

它不压缩向量，但不会在它们之上增加开销。
它不支持添加id（add_with_ids），只支持顺序添加，因此如果需要 add_with_ids，请使用“IDMap,Flat”。

_**是否支持 GPU**_： yes

## 2. 是否关心内存？

请记住，所有Faiss索引都存储在RAM中。
以下的这些考虑是，如果我们不需要精确的结果而 RAM 又是限制因素，那么，我们就需要在内存的限制下，来优化精确-速度比（precision-speed tradeoff）。

### 如果不需要关心内存：“HNSWx”

如果你有大量的RAM或数据集很小，HNSW 是最好的选择，它是一个非常快速和准确的索引。
x 的范围是[4, 64]，它表示了每个向量的链接数量，越大越精确，但是会使用越多的内存。

速度-精确比（speed-accuracy tradeoff）可以通过 efSearch 参数来设置。
每个向量的内存使用是情况是（d * 4 + x * 2 * 4 ）。

HNSW 只支持顺序添加（不是add_with_ids），所以在这里再次使用 IDMap 作为前缀（如果需要）。 
HNSW 不需要训练，也不支持从索引中删除矢量。 

_**是否支持 GPU**_： no

### 如果有些担心内存：“...,Flat”

“...” 表示必须事先执行数据集的聚类（如下所示）。
在聚类之后，“Flat”只是将向量组织到不同桶中，因此它不会压缩它们，存储大小与原始数据集的大小相同。
速度和精度之间的权衡是通过 nprobe 参数设置的。

_**是否支持 GPU**_： yes（但是聚类方法也需要支持GPU）

### 如果相当关心内存：“PCARx,...,SQ8”

如果存储整个向量太昂贵，则执行两个操作：
- 使用尺寸为x的PCA以减小尺寸 
- 每个矢量分量的标量量化为1个字节。

因此，总存储量是每个向量 x 个字节。

_**是否支持 GPU**_： no

### 如果非常关心内存：“OPQx_y,...,PQx”

PQx 代表了通过一个product quantizer压缩向量为 x 字节。
x 一般 <= 64，对于较大的值，SQ 通常是准确和快速的。

OPQ 是向量的线性变换，使其更容易压缩。
y是一个维度：
- y是x的倍数（必需）
- y <= d，d为输入向量的维度（最好）
- y <= 4*x（最好）

_**是否支持 GPU**_： yes（注意：OPQ转换是在软件中完成的，但它不是性能关键）

## 3. 数据集有多大

这个问题用于选择聚类选项（就是上面的那些”...“）。
数据集聚集到存储桶中，在搜索时，只访问了一小部分存储桶（nprobe 个存储桶）。
聚类是在数据集矢量的代表性样本上执行的，通常是数据集的样本。
我们指出该样本的最佳大小。

### 如果向量数量低于1百万："...,IVFx,..."

当数据集的数量为 N 时，那么 x 应该处于 4 * sqrt(N) 和 16 * sqrt(N) 之间。
这只是用k-means聚类向量。
你需要 30 * x 到 256 * x 的矢量进行训练（越多越好）。

_**是否支持 GPU**_： yes

### 如果向量数量位于1百万-1千万之间："...,IMI2x10,..."

（这里x是文字x，而不是数字）

IMI在训练向量上执行具有2^10个质心的 k-means，但它在向量的前半部分和后半部分独立地执行。
这将簇的数量增加到 2^(2 * 10)。您将需要大约64 * 2 ^ 10个向量进行训练。

_**是否支持 GPU**_： no

### 如果向量数量位于1千万-1亿之间："...,IMI2x12,..."

与上面相同，将10替换为12。

_**是否支持 GPU**_： no

### 如果向量数量位于1亿-10亿之间："...,IMI2x14,..."

与上面相同，将10替换为14。

_**是否支持 GPU**_： no

---

# 基本的 Index

## 方法摘要

详情参考 [这里](https://github.com/facebookresearch/faiss/wiki/Faiss-indexes)

## 单元-探测（Cell-probe） 方法

以失去保证以找到最近邻居为代价来加速该过程的典型方法是采用诸如k均值的分区技术。
相应的算法有时被称为 cell-probe 方法：

我们使用基于多探测的基于分区的方法（可以联想到best-bin KD-tree的一种变体）。
- 特征空间被划分为 ncells 个单元格。
- 由于散列函数（在k均值的情况下，对最靠近查询的质心的分配），数据库向量被分配给这些单元中的一个，并且存储在由ncells反向列表形成的反向文件结构中。
- 在查询时，会选择一组 nprobe 个的反向列表
- 将查询与分配给这些列表的每个数据库向量进行比较

这样做，只有一小部分数据库与查询进行比较：作为第一个近似值，这个比例是 nprobe / ncells，但请注意，这个近似值通常被低估，因为反向列表的长度不相等。 
当未选择给定查询的最近邻居的单元格时，将显示失败案例。

在C++中，相应的索引是索引IndexIVFFlat。

构造函数将索引作为参数，用于对反转列表进行赋值。
在该索引中搜索查询，并且返回的向量id（s）是应该被访问的反向列表。

