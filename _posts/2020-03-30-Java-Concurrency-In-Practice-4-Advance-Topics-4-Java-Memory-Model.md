---
layout: post
title: Java 并发编程实战-学习日志（四）4：Java 内存模型
date: 2020-03-30 18:11:04
author: admin
comments: true
categories: [Java]
tags: [Java, Concurrency, Java Concurrency In Practice]
---


<!-- more -->

---

* 目录
{:toc}
---

## 什么是内存模型及为什么需要它

如果缺少同步，那么将会有许多因素使得线程无法立即甚至永远看到一个线程的操作结果。

- 编译器把变量保存在本地寄存器而不是内存中
- 编译器中生成的指令顺序，可以与源代码中的顺序不同
- 处理器采用乱序或并行的方式来执行指令
- 保存在处理器本地缓存中的值，对于其他处理器是不可见

在单线程中，只要程序的最终结果与在严格串行环境中执行的结果相同，那么上述所有操作都是允许的。

在多线程中，JVM通过同步操作来找出这些协调操作将在何时发生。

JMM规定了JVM必须遵循一组最小保证，这组保证规定了对变量的写入操作在何时将对其他线程可见。



## 1. 平台的内存模型

每个处理器都拥有自己的缓存，并且定期地与主内存进行协调，在不同的处理器架构中提供了不同级别的缓存一致性，即允许不同的处理器在任意时刻从同一个存储位置上看到不同的值。JVM通过在适当的位置上插入**内存栅栏**来屏蔽在JMM与底层平台内存模型之间的差异。**Java程序不需要指定内存栅栏的位置，而只需通过正确地使用同步来找出何时将访问共享状态**。

## 2. 重排序

各种使操作延迟或者看似乱序执行的不同原因，都可以归为重排序，内存级的重排序会使程序的行为变得不可预测。

```java
Thread one = new Thread(new Runnable() {
  public void run() {
    a = 1;
    x = b;
  }
});
```







## 未完待续。。。。。。
