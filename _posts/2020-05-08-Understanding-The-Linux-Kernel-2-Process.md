---
layout: post
title: 深入理解 Linux 内核（二）：进程
date: 2020-05-08 18:11:04
author: admin
comments: true
categories: [Linux]
tags: [Linux, Linux Kernel]
---

进程的概念是任何多线程操作系统的基石。进程通常被定义为一个正在运行的程序实例；因此，如果16个用户在同一时刻运行vi，就会有16个独立的进程（虽然他们共享相同的可执行代码）。进程在linux源码里经常被叫做任务（tasks）或者线程（threads）。

<!-- more -->

---

* 目录
{:toc}
---

## 进程、轻量级进程和线程

进程是一个正在运行的程序实例。你可以把它看做一个数据结构集合，它完整的描述了程序的执行进度。

从内核的角度看，进程的作用是充当一个系统资源（cpu时间，内存等）被分配的实体。

旧版本的linux内核不提供多线程支持。从内核角度看，一个多线程应用仅仅是一个普通的进程，它的多个执行流完全是在用户态创建、处理、和调度的，通常是使用一个符合posix标准的pthread库来实现。

Linux使用轻量级进程来提供对多线程更好的支持。基本地，两个轻量级进程可能共享相同的资源，像地址空间、打开的文件等。每当其中一个修改共享资源时，另一个能立刻看到这个改变。当然，这两个进程必须在访问共享资源时相互同步。

一个简单粗暴的实现多线程应用的方式是使轻量级进程和每个线程相关联。这种方式下，通过共享相同的内存地址空间、相同的打开文件集等，多个线程可以访问一组相同的应用程序数据结构；同时，每个线程又可以被内核独立调度，因此一个睡眠时，另一个还能继续运行。

## 进程描述符

为了管理进程，内核必须对每个进程正在做什么有一个清晰的画面。比如，它必须知道进程的优先级、它是正在运行还是被某个事件阻塞、它的地址空间是多少、它被允许访问哪些地址等等。

进程描述符发挥了这些作用，它是一个task_struct类型的结构，包含与单个进程有关的所有信息。正因为存放了这么多信息，进程描述符是非常复杂的。除了大量的包含进程属性的字段，文件描述符还包含若干个指向其他数据结构的指针，这些数据结构又包含指向其他结构的指针。

### 1. 进程状态

运行状态：TASK_RUNNING

- 进程正在运行或者等待运行。

可中断的等待状态：TASK_INTERRUPTIBLE

- 进程被挂起（睡眠）直到某些条件变为true。产生一个硬件中断、释放一个进程正在等待的系统资源、或者传递一个信号，这些都会唤起一个进程（把它的状态恢复为TASK_RUNNING）。

不可中断的等待状态：TASK_UNINTERRUPTIBLE

- 类似于TASK_INTERRUPTIBLE，唯一的不同是当传递一个信号给挂起的进程时，它的状态保持不变。这个状态很少被使用，但却是有用的，在某些特殊的情况下，进程在等待一个事件时不能被中断。举个例子，当一个进程打开文件设备，相应的设备驱动程序开始探测对应的硬件设备，在探测结束之前这个设备驱动程序必须不能被中断，否则硬件设备将会停留在不可预知的状态。

暂停状态：TASK_STOPPED

- 进程已经被暂停运行（只是被暂停运行，并不是终止运行）；进程在收到这些信号后进入该状态：SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU。

跟踪状态：TASK_TRACED

- 进程被调试器暂停了运行。当一个进程被其他进程监视时（比如当调试器执行ptrace来监视一个test程序时），每一个信号都会使该进程进入TASK_TRACED状态。

另外，有两个状态可以被同时存储于进程描述符state和exit_state字段；从名字就可以看出，只有在进程终止了才会进入这两种状态：

僵死状态：EXIT_ZOMBIE

- 进程已终止，但是父进程还没有发起wait4()或waitpid()系统调用来获取僵尸进程的信息。在wait族函数被调用之前，内核不能丢弃僵尸进程的描述符中的任何数据，因为父进程可能会用到。（查看本章最后一节中的“进程移除”一段）。

僵死撤销状态：EXIT_DEAD

- 这是最后的状态：进程已经被系统移除了，因为父进程刚调用了wait族函数。从EXIT_ZOMBIE到EXIT_DEAD状态的转换避免了一种竞争态：当其他线程对同一个进程调用了wait族函数时（查看第5章）。

### 2. 标识进程

进程和进程描述符严格的一对一关系使得task_struct的32位地址成为内核标识进程的有效手段。这些地址被称为进程描述符指针。内核对进程的大部分引用都是通过进程描述符指针的。

另一方面，类unix操作系统允许用户通过一个叫做进程ID（PID）的数字来标识进程，这个数字被存储在进程描述符的pid字段里。PID按顺序编号：新创建进程的PID通常是在前一个创建的进程的PID上加1。当然，PID值有上限，当内核达到了这个上限，它必须回收更小的未使用的PID。PID的最大默认值为32767（`PID_MAX_DEFAULT - 1`）;系统管理员可以通过向`/proc/sys/kernel/pid_max`（/proc挂载了一个特殊的文件系统，请查看第12章“特殊文件系统”）文件写入一个更小的值来减小这个上限。在64位架构体系下，系统管理员可以把上限值扩大到4,194,303。

当回收PID数值时，内核维护了一个可以表示哪些PID正在使用、哪些是空闲的`pidmap_array`位图。因为一个页帧大小是32768比特，在32位体系架构上，`pidmap_array`存储在单个页面中。 但是，在64位架构上，当内核使用了一个超过当前页大小的PID数值时，更多的页会加到位图中。这些页面从来不被释放。

Linux给系统中每个进程或者轻量级进程关联一个不同的PID。（我们将在本章之后看到，在多处理器操作系统中有小小的例外。）这种方法允许最大的灵活性，因为每个系统中的执行上下文都可以被唯一标识。

另一方面，UNIX程序员们希望同一组中的线程具有相同PID。比如，给一个PID发送信号来影响组中的所有线程。实际上，POSIX 1003.1c标准已经声明一个多线程应用程序中的所有线程必须拥有相同的PID。

为了满足这个标准，Linux使用了线程组技术。线程共享的标识符是线程组leader的PID，也就是组里第一个轻量级进程的PID；它存储在进程描述符的tgid字段里。getpid()系统调用返回当前进程的tgid值，而不是pid，因此一个多线程应用程序中的所有线程共享相同的标识符。大多数进程属于只有一个成员的线程组（单线程），作为组leader，它们的tgid和pid具有相同的值，如此getpid()系统调用对这类进程也可以正常工作。

#### 进程描述符的处理

进程是一个动态的实体对象，它们的生命周期短至几毫秒，长至几个月。因此内核必须能够同时处理很多个进程，把进程描述符存储在动态内存中而不是永久分配给内核的内存区域。对于每个进程，Linux在一个进程内存区域封装了两个不同的数据结构：一个跟进程描述符关联的小数据结构，叫做`thread_info`结构体，和内核态进程栈。

#### 标识当前进程

刚才提到的thread_info结构和内核栈的紧密关系对提高效率大有益处：内核通过esp可以很方便的获得当前正在运行的进程的thread_info地址。实际上，如果thread_union大小为8KB（2^13字节），内核通过掩码计算出esp的13个最低有效位来得到thread_info的基地址；类似的，如果thread_union为4KB，则取出12个最低有效位。current_thread_info函数可以实现这些功能，它会产生类似于下面的汇编指令：
```assembly
movl $0xffffe000,%ecx /* or 0xfffff000 for 4KB stacks */
andl %esp,%ecx
movl %ecx,p
```

当这三条指令执行完毕，p指向当前运行进程的`thread_info`结构的地址。

多数情况下内核需要的是进程描述符的地址而不是`thread_info`的地址。为了得到一个cpu上正在运行的进程的描述符指针，内核使用current宏，它等同于`current_thread_info->task`，并产生以下汇编指令：

```assembly
movl $0xffffe000,%ecx /* or 0xfffff000 for 4KB stacks */
andl %esp,%ecx
movl (%ecx),p
123
```

因为task为`thread_info`结构的第一个字段，所以当执行完这些指令后，p刚好指向该CPU当前正在运行进程的描述符。

current宏经常出现在内核代码中，用来获取进程描述符中的字段。比如：current->pid返回当前进程的PID。

另一个把进程描述符和栈存放在一起的好处体现在多处理器系统上：仅仅通过检查stack就可以获取每个CPU上正在运行的进程。早期的Linux版本没有把这两个结构存储在一起，相反的，它们使用一个全局静态变量current来定义当前运行的进程。在多处理器系统上，就需要把current定义为每个CPU独有的变量。

#### 双向链表

每个链表都需要实现一系列的基础操作：初始化、插入、删除、遍历等等。对每个不同的链表都重复实现这些基础操作不仅浪费程序员的时间也浪费了内存。

因此，Linux内核定义了`list_head`结构，它只有next和prev字段名分别表示一个通用双链表的前一个和下一个元素。但是，有一点必须要注意:`list_head`存放的是其他`list_head`的地址，而不是整个包含`list_head`的结构的地址.

`LIST_HEAD(list_name)`宏用来新建一个链表。它声明一个`list_head`类型的变量`list_name`，这是个傀儡节点，它充当新链表的头节点占位符，并初始化`list_head`的prev和next字段使得它们指向`list_name`节点自身。

Linux2.6内核支持另一种类型的双向链表，与`list_head`链表的主要不同在于它不是循环的。它主要在内存比较宝贵的哈希表里会用到，而且不能在O(1)的时间内寻找最后一个元素。链表头部存储在`hlist_head`结构里面，它只是一个简单的指向链表第一个元素的指针（链表为空时值为NULL）。每个元素保存在`hlist_node`结构里，它包含一个指向下一个元素的next指针和指向前一个元素的next字段的pprev指针（pprev是个很巧妙的设计）。因为链表不是循环的，最后一个元素的next为NULL（注:原文说第一个元素的pprev也为NULL，应当是不正确的，事实上它指向head的first字段）。

#### 进程列表



我们将要研究的第一个双链表是进程列表，它把所有系统存在的进程描述符串在一起。每个`task_struct`结构包含一个`list_head`类型的tasks字段，它的prev和next字段分别指向前一个和后一个`task_struct`元素。

进程链表的头部是一个`task_struct`类型的`init_task`描述符,它是所谓的进程0或交换区的描述符（请查看本章之后的“内核线程”一节）。`init_task`的tasks->prev字段指向链表最后一个元素的tasks字段。

`SET_LINKS`和`REMOVE_LINKS`宏分别用来从进程列表中插入和删除进程描述符。这些宏也关系到进程间的父子关系（查看本章之后的“进程是怎么组织的”一节）。

另一个有用的宏，叫做`for_each_process`，遍历整个进程列表。它的定义如下：

```c
#define for_each_process(p) \
for (p=&init_task; (p=list_entry((p)-> tasks.next, \
                                    struct task_struct, tasks) \
                                   ) != &init_task; )
```

这个宏是循环控制语句，内核程序员把循环体添加在其后面。请注意`init_task`是怎样只充当链表头的。这个宏开始时移动`init_task`到下一个task，然后继续循环一直到重新遇到`init_task`时为止（多亏了循环链表）。每次迭代，传递给宏的参数包含的当前扫描的进程描述符，也就是`list_entry`宏返回的值。

#### `TASK_RUNNING`进程链表

当寻找一个新的进程来运行在CPU上时，内核只需要关注那些可运行的进程（即处于`TASK_RUNNING`状态的进程）。

早期的Linux版本把所有可运行的进程放在同一个runqueue链表里面。因为要按进程优先级来维护链表成本太高，早期的调度器被迫扫描整个链表，为了选出最好的进程来运行。

Linux2.6用不同的方式来实现这个运行队列。目的是为了能使调度器在常量的时间内选出最好的可运行进程，而与可运行进程的数量无关。我们会在之后的第7张详细描述这种运行队列，这里只提供一些基本信息。

实现提高调度速度的策略包括把运行队列分割成许多可执行进程链表，每个优先级一个链表。每个`task_struct`描述符包含一个`list_head`类型的`run_list`字段。如果一个进程优先级为k（k为0-139之间的一个值），`run_list`字段把这个进程描述符链接到优先级为k的可运行进程链表。此外，对于多处理器系统，每个cpu有自己的运行队列。这是一个典型的增加数据结构复杂性来提高性能的例子：为了更高效地调度，把运行队列分割成140个不同的链表。

我们将会看到，内核必须为每个运行队列保存许多数据；但是，运行队列的主要数据结构是多个进程描述符链表；



### 3. 进程之间的关系

一个程序和它创建进程之间有父子关系。当一个进程创建多个子进程时，这些子进程具有兄弟关系。为了表示这些关系，必须在进程描述符里引入几个字段，表3-3里列出了给定进程P的这些字段。进程0和进程1由内核创建；我们将在本章之后看到进程1是所有其他进程的祖先。

**用来表示父子关系的进程描述符字段**

| 字段名      | 描述                                                         |
| ----------- | ------------------------------------------------------------ |
| real_parent | 指向创建进程P的进程的描述符，若不存在则指向进程1（init）的描述符。（因此，当用户启动一个后台进程并退出shell后，这个后台进程会立刻变成init进程的子进程。） |
| parent      | 指向进程P的真实父进程（它是当该进程终止后必须通知的进程）；它和`real_parent`极为相似，只在某些情况下可能会不同，比如另一个进程对P进程发起ptrace系统调用(请查看第20章“跟踪执行”一节)。 |
| children    | 包含所有由P创建的所有子进程的链表的头                        |
| sibling     | 指向兄弟进程链表中的下一个和前一个元素，它们和P具有相同的父进程。 |

此外，进程之间还有其他关系：一个进程可以是一个进程组或一个登陆会话的leader，它也可以是一个线程组的leader，它也可以跟踪其他进程的执行.

**建立非父子进程之间关系的描述符字段**

| 字段名          | 描述                                                         |
| --------------- | ------------------------------------------------------------ |
| group_leader    | P所属进程组leader进程的描述符指针                            |
| signal->pgrp    | P所属进程组leader进程的PID                                   |
| tgid            | P所属线程组leader进程的PID                                   |
| signal->session | P所属登录会话leader进程的PID                                 |
| ptrace_children | 被调试器跟踪的P的子进程链表的头                              |
| ptrace_list     | 指向实际父进程的被跟踪进程列表的下一个和前一个元素（当P被跟踪时用到） |

#### PID哈希表和链表

在一些情况下，内核必须能够由PID导致相应的进程描述符。比如在kill()系统调用里面。当进程P1想要发送一个信号给另一个进程P2时，它调用kill()系统调用，以P2的PID作为参数。内核由P2的PID导出进程描述符指针，然后从进程描述里提取出记录未决信号的数据结构指针。

顺序扫描进程列表并校验pid字段是可行的方案但是非常低效。为了加速搜索，引入了四个哈希表。为什么有多个哈希表？原因很简单，因为进程描述符对不同类型的PID有不同的字段（见表3-5），每种类型的PID需要有自己的哈希表。

**四个哈希表和他们对应的进程描述符字段**

| 哈希表类型   | 字段名  | 描述              |
| ------------ | ------- | ----------------- |
| PIDTYPE_PID  | pid     | 进程的PID         |
| PIDTYPE_TGID | tgid    | 线程组leader的PID |
| PIDTYPE_PGID | pgrp    | 进程组leader的PID |
| PIDTYPE_SID  | session | 会话leader的PID   |

这四个哈希表在内核初始化的时候被动态分配，它们的地址存储在`pid_hash`数组里。单个哈希表的大小取决于可用的RAM；比如，对于512M内存的系统，每个哈希表存放在四个页帧中并包含2048条数据。

Linux使用链表来解决碰撞问题；每个表项存放的是碰撞的进程描述符的双向链表的头。

### 4. 进程之是怎么被组织的

运行队列链表把所有处于`TASK_RUNNING`状态的进程组织在一起。对于处在其他状态的进程，则需要不同的对待，Linux有以下两种选择。

- 处于`TASK_STOPPED`，`EXIT_ZOMBIE`或者`EXIT_DEAD`状态的进程没有用特殊的链表来连接。没有必要把任何处于这些状态的进程组织在一起，因为暂停、僵尸或者死亡的进程只通过PID或者通过某个特定进程的子进程链表来访问。
- 处于`TASK_INTERRUPTIBLE`或者`TASK_UNINTERRUPTIBLE`状态的进程被分成很多种类，每种对应一个特殊的事件。在这种情况下，只从进程状态不能快速获取到进程，所以必须要引入额外的进程链表。这些就是接下来将要探讨的等待队列。

#### 等待队列

等待队列在内核里有几个用处，尤其是中断处理，进程同步，和定时器。因为接下来的章节会讨论这些话题，这里我们只简单的说一个进程必定经常等待某些事件的发生，比如磁盘操作的完成，系统资源的释放，定时器的触发等。等待队列实现了事件上的条件等待：一个希望等待某个特殊事件的进程把自己放到合适的等待队列里面并让出控制权。因此，等待队存放了一组睡眠中的进程，这些进程将会在某个条件为true时被内核唤醒。

等待队列本质是一个双链表，存放包含进程描述符指针的元素。每个等待队列由一个`wait_queue_head_t`类型的队列头来定义：

```c
struct _ _wait_queue_head {
    spinlock_t lock;
    struct list_head task_list;
};
typedef struct _ _wait_queue_head wait_queue_head_t;
```

因为等待队列会被各种中断处理函数和内核函数修改，当并发访问这个双链表时必须对其加以保护，否则可能导致不可预知的结果。同步是用队列头中的自旋锁lock来实现的。`task_list`字段是等待进程链表的头部。

等待队列的数据元素类型为`wait_queue_t`：

```c
struct _ _wait_queue {
    unsigned int flags;
    struct task_struct * task;
    wait_queue_func_t func;
    struct list_head task_list;
};
typedef struct _ _wait_queue wait_queue_t;
```

等待队列中的每个元素都代表了一个睡眠中并等待某个事件发生的进程；它的描述符地址存储在task字段。`task_list`字段则保存了所有等待相同事件的进程链表。

然而，唤起等待队列中的全部进程并不总是合适的。举例来说，比如两个或者更多的进程正等待对某个待释放资源的互斥访问，这时候只唤起等待队列中的一个进程是有意义的。一个进程得到资源，其他进程继续睡眠。（这避免了有名的“惊群”问题，即多个竞争同一个资源的进程被同时唤醒，而这个资源只能同时被一个进程访问，结果导致其他进程又重新进入sleep状态。）

因此，sleep中的进程可以分为两种：互斥的进程（相应等待队列元素中的flag等于1）被内核有选择的唤醒，而非互斥的进程都被唤醒。如果进程等待的资源只能授予一个进程，则它们是互斥进程，相反，如果等待的事件与所有等待中的进程都相关，则它们是非互斥的。比如，考虑一组进程正等待磁盘数据块的传输，一旦传输完成，所有的进程必须被唤醒。我们接下来会看到，等待队列元素中的func字段定义了等待的进程是怎样被唤醒的。





## 未完待续。。。。。