---
layout: post
title: 深入理解 Linux 内核（二）：进程
date: 2020-05-08 18:11:04
author: admin
comments: true
categories: [Linux]
tags: [Linux, Linux Kernel]
---

进程的概念是任何多线程操作系统的基石。进程通常被定义为一个正在运行的程序实例；因此，如果16个用户在同一时刻运行vi，就会有16个独立的进程（虽然他们共享相同的可执行代码）。进程在linux源码里经常被叫做任务（tasks）或者线程（threads）。

<!-- more -->

---

* 目录
{:toc}
---

## 进程、轻量级进程和线程

进程是一个正在运行的程序实例。你可以把它看做一个数据结构集合，它完整的描述了程序的执行进度。

从内核的角度看，进程的作用是充当一个系统资源（cpu时间，内存等）被分配的实体。

旧版本的linux内核不提供多线程支持。从内核角度看，一个多线程应用仅仅是一个普通的进程，它的多个执行流完全是在用户态创建、处理、和调度的，通常是使用一个符合posix标准的pthread库来实现。

Linux使用轻量级进程来提供对多线程更好的支持。基本地，两个轻量级进程可能共享相同的资源，像地址空间、打开的文件等。每当其中一个修改共享资源时，另一个能立刻看到这个改变。当然，这两个进程必须在访问共享资源时相互同步。

一个简单粗暴的实现多线程应用的方式是使轻量级进程和每个线程相关联。这种方式下，通过共享相同的内存地址空间、相同的打开文件集等，多个线程可以访问一组相同的应用程序数据结构；同时，每个线程又可以被内核独立调度，因此一个睡眠时，另一个还能继续运行。

## 进程描述符

为了管理进程，内核必须对每个进程正在做什么有一个清晰的画面。比如，它必须知道进程的优先级、它是正在运行还是被某个事件阻塞、它的地址空间是多少、它被允许访问哪些地址等等。

进程描述符发挥了这些作用，它是一个task_struct类型的结构，包含与单个进程有关的所有信息。正因为存放了这么多信息，进程描述符是非常复杂的。除了大量的包含进程属性的字段，文件描述符还包含若干个指向其他数据结构的指针，这些数据结构又包含指向其他结构的指针。

### 1. 进程状态

运行状态：TASK_RUNNING

- 进程正在运行或者等待运行。

可中断的等待状态：TASK_INTERRUPTIBLE

- 进程被挂起（睡眠）直到某些条件变为true。产生一个硬件中断、释放一个进程正在等待的系统资源、或者传递一个信号，这些都会唤起一个进程（把它的状态恢复为TASK_RUNNING）。

不可中断的等待状态：TASK_UNINTERRUPTIBLE

- 类似于TASK_INTERRUPTIBLE，唯一的不同是当传递一个信号给挂起的进程时，它的状态保持不变。这个状态很少被使用，但却是有用的，在某些特殊的情况下，进程在等待一个事件时不能被中断。举个例子，当一个进程打开文件设备，相应的设备驱动程序开始探测对应的硬件设备，在探测结束之前这个设备驱动程序必须不能被中断，否则硬件设备将会停留在不可预知的状态。

暂停状态：TASK_STOPPED

- 进程已经被暂停运行（只是被暂停运行，并不是终止运行）；进程在收到这些信号后进入该状态：SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU。

跟踪状态：TASK_TRACED

- 进程被调试器暂停了运行。当一个进程被其他进程监视时（比如当调试器执行ptrace来监视一个test程序时），每一个信号都会使该进程进入TASK_TRACED状态。

另外，有两个状态可以被同时存储于进程描述符state和exit_state字段；从名字就可以看出，只有在进程终止了才会进入这两种状态：

僵死状态：EXIT_ZOMBIE

- 进程已终止，但是父进程还没有发起wait4()或waitpid()系统调用来获取僵尸进程的信息。在wait族函数被调用之前，内核不能丢弃僵尸进程的描述符中的任何数据，因为父进程可能会用到。（查看本章最后一节中的“进程移除”一段）。

僵死撤销状态：EXIT_DEAD

- 这是最后的状态：进程已经被系统移除了，因为父进程刚调用了wait族函数。从EXIT_ZOMBIE到EXIT_DEAD状态的转换避免了一种竞争态：当其他线程对同一个进程调用了wait族函数时（查看第5章）。

### 2. 标识进程

进程和进程描述符严格的一对一关系使得task_struct的32位地址成为内核标识进程的有效手段。这些地址被称为进程描述符指针。内核对进程的大部分引用都是通过进程描述符指针的。

另一方面，类unix操作系统允许用户通过一个叫做进程ID（PID）的数字来标识进程，这个数字被存储在进程描述符的pid字段里。PID按顺序编号：新创建进程的PID通常是在前一个创建的进程的PID上加1。当然，PID值有上限，当内核达到了这个上限，它必须回收更小的未使用的PID。PID的最大默认值为32767（`PID_MAX_DEFAULT - 1`）;系统管理员可以通过向`/proc/sys/kernel/pid_max`（/proc挂载了一个特殊的文件系统，请查看第12章“特殊文件系统”）文件写入一个更小的值来减小这个上限。在64位架构体系下，系统管理员可以把上限值扩大到4,194,303。

当回收PID数值时，内核维护了一个可以表示哪些PID正在使用、哪些是空闲的`pidmap_array`位图。因为一个页帧大小是32768比特，在32位体系架构上，`pidmap_array`存储在单个页面中。 但是，在64位架构上，当内核使用了一个超过当前页大小的PID数值时，更多的页会加到位图中。这些页面从来不被释放。

Linux给系统中每个进程或者轻量级进程关联一个不同的PID。（我们将在本章之后看到，在多处理器操作系统中有小小的例外。）这种方法允许最大的灵活性，因为每个系统中的执行上下文都可以被唯一标识。

另一方面，UNIX程序员们希望同一组中的线程具有相同PID。比如，给一个PID发送信号来影响组中的所有线程。实际上，POSIX 1003.1c标准已经声明一个多线程应用程序中的所有线程必须拥有相同的PID。

为了满足这个标准，Linux使用了线程组技术。线程共享的标识符是线程组leader的PID，也就是组里第一个轻量级进程的PID；它存储在进程描述符的tgid字段里。getpid()系统调用返回当前进程的tgid值，而不是pid，因此一个多线程应用程序中的所有线程共享相同的标识符。大多数进程属于只有一个成员的线程组（单线程），作为组leader，它们的tgid和pid具有相同的值，如此getpid()系统调用对这类进程也可以正常工作。

#### 进程描述符的处理

进程是一个动态的实体对象，它们的生命周期短至几毫秒，长至几个月。因此内核必须能够同时处理很多个进程，把进程描述符存储在动态内存中而不是永久分配给内核的内存区域。对于每个进程，Linux在一个进程内存区域封装了两个不同的数据结构：一个跟进程描述符关联的小数据结构，叫做`thread_info`结构体，和内核态进程栈。

#### 标识当前进程

刚才提到的thread_info结构和内核栈的紧密关系对提高效率大有益处：内核通过esp可以很方便的获得当前正在运行的进程的thread_info地址。实际上，如果thread_union大小为8KB（2^13字节），内核通过掩码计算出esp的13个最低有效位来得到thread_info的基地址；类似的，如果thread_union为4KB，则取出12个最低有效位。current_thread_info函数可以实现这些功能，它会产生类似于下面的汇编指令：
```assembly
movl $0xffffe000,%ecx /* or 0xfffff000 for 4KB stacks */
andl %esp,%ecx
movl %ecx,p
```

当这三条指令执行完毕，p指向当前运行进程的`thread_info`结构的地址。

多数情况下内核需要的是进程描述符的地址而不是`thread_info`的地址。为了得到一个cpu上正在运行的进程的描述符指针，内核使用current宏，它等同于`current_thread_info->task`，并产生以下汇编指令：

```assembly
movl $0xffffe000,%ecx /* or 0xfffff000 for 4KB stacks */
andl %esp,%ecx
movl (%ecx),p
123
```

因为task为`thread_info`结构的第一个字段，所以当执行完这些指令后，p刚好指向该CPU当前正在运行进程的描述符。

current宏经常出现在内核代码中，用来获取进程描述符中的字段。比如：current->pid返回当前进程的PID。

另一个把进程描述符和栈存放在一起的好处体现在多处理器系统上：仅仅通过检查stack就可以获取每个CPU上正在运行的进程。早期的Linux版本没有把这两个结构存储在一起，相反的，它们使用一个全局静态变量current来定义当前运行的进程。在多处理器系统上，就需要把current定义为每个CPU独有的变量。



## 未完待续。。。。。