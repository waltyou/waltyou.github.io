---
layout: post
title: 深入理解 Linux 内核（二）：进程
date: 2020-05-08 18:11:04
author: admin
comments: true
categories: [Linux]
tags: [Linux, Linux Kernel]
---

进程的概念是任何多线程操作系统的基石。进程通常被定义为一个正在运行的程序实例；因此，如果16个用户在同一时刻运行vi，就会有16个独立的进程（虽然他们共享相同的可执行代码）。进程在linux源码里经常被叫做任务（tasks）或者线程（threads）。

<!-- more -->

---

* 目录
{:toc}
---

## 进程、轻量级进程和线程

进程是一个正在运行的程序实例。你可以把它看做一个数据结构集合，它完整的描述了程序的执行进度。

从内核的角度看，进程的作用是充当一个系统资源（cpu时间，内存等）被分配的实体。

旧版本的linux内核不提供多线程支持。从内核角度看，一个多线程应用仅仅是一个普通的进程，它的多个执行流完全是在用户态创建、处理、和调度的，通常是使用一个符合posix标准的pthread库来实现。

Linux使用轻量级进程来提供对多线程更好的支持。基本地，两个轻量级进程可能共享相同的资源，像地址空间、打开的文件等。每当其中一个修改共享资源时，另一个能立刻看到这个改变。当然，这两个进程必须在访问共享资源时相互同步。

一个简单粗暴的实现多线程应用的方式是使轻量级进程和每个线程相关联。这种方式下，通过共享相同的内存地址空间、相同的打开文件集等，多个线程可以访问一组相同的应用程序数据结构；同时，每个线程又可以被内核独立调度，因此一个睡眠时，另一个还能继续运行。

## 进程描述符

为了管理进程，内核必须对每个进程正在做什么有一个清晰的画面。比如，它必须知道进程的优先级、它是正在运行还是被某个事件阻塞、它的地址空间是多少、它被允许访问哪些地址等等。

进程描述符发挥了这些作用，它是一个task_struct类型的结构，包含与单个进程有关的所有信息。正因为存放了这么多信息，进程描述符是非常复杂的。除了大量的包含进程属性的字段，文件描述符还包含若干个指向其他数据结构的指针，这些数据结构又包含指向其他结构的指针。

### 1. 进程状态

运行状态：TASK_RUNNING

- 进程正在运行或者等待运行。

可中断的等待状态：TASK_INTERRUPTIBLE

- 进程被挂起（睡眠）直到某些条件变为true。产生一个硬件中断、释放一个进程正在等待的系统资源、或者传递一个信号，这些都会唤起一个进程（把它的状态恢复为TASK_RUNNING）。

不可中断的等待状态：TASK_UNINTERRUPTIBLE

- 类似于TASK_INTERRUPTIBLE，唯一的不同是当传递一个信号给挂起的进程时，它的状态保持不变。这个状态很少被使用，但却是有用的，在某些特殊的情况下，进程在等待一个事件时不能被中断。举个例子，当一个进程打开文件设备，相应的设备驱动程序开始探测对应的硬件设备，在探测结束之前这个设备驱动程序必须不能被中断，否则硬件设备将会停留在不可预知的状态。

暂停状态：TASK_STOPPED

- 进程已经被暂停运行（只是被暂停运行，并不是终止运行）；进程在收到这些信号后进入该状态：SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU。

跟踪状态：TASK_TRACED

- 进程被调试器暂停了运行。当一个进程被其他进程监视时（比如当调试器执行ptrace来监视一个test程序时），每一个信号都会使该进程进入TASK_TRACED状态。

另外，有两个状态可以被同时存储于进程描述符state和exit_state字段；从名字就可以看出，只有在进程终止了才会进入这两种状态：

僵死状态：EXIT_ZOMBIE

- 进程已终止，但是父进程还没有发起wait4()或waitpid()系统调用来获取僵尸进程的信息。在wait族函数被调用之前，内核不能丢弃僵尸进程的描述符中的任何数据，因为父进程可能会用到。（查看本章最后一节中的“进程移除”一段）。

僵死撤销状态：EXIT_DEAD

- 这是最后的状态：进程已经被系统移除了，因为父进程刚调用了wait族函数。从EXIT_ZOMBIE到EXIT_DEAD状态的转换避免了一种竞争态：当其他线程对同一个进程调用了wait族函数时（查看第5章）。



## 未完待续。。。。。
